# DSA for Interviews: A Practical Guide

Hi there! ðŸ‘‹ This repository is a curated collection of Data Structures & Algorithms patterns and problems, designed to prepare you for technical interviews for roles like **Google STEP, Microsoft SWE Intern, Amazon SDE Intern, Meta University (outside Ireland)**, and other top-tier software engineering internships.

It's not just a list of solutions. It's a structured learning path focused on **recognizing patterns**, understanding **trade-offs**, and moving from a **brute-force idea to an optimal solution**.

All solutions in this repository are written in **Java**.

---

## ðŸ’¡ Core Philosophy: The Journey to Optimal

The goal of a technical interview isn't just to get the right answer, but to demonstrate *how you think*. That's why every problem in this repo follows a specific structure:

1.  **Brute Force:** The simple, straightforward first attempt.
2.  **Analysis:** Identifying *why* the brute-force solution is inefficient.
3.  **Optimal Solution:** Applying the correct data structure or algorithmic pattern to solve the problem efficiently.

By studying this way, you learn to deconstruct problems and build effective solutions under pressure.

---

## ðŸ§­ How to Use This Repo

- **For Revision:** Use the checklists below to track your progress and quickly review key patterns before an interview.
- **For Deep Learning:** Dive into each problem's dedicated folder. Every folder contains:
    - `README.md` explaining the thought process from brute-force to optimal.
    - `BruteForce.java` containing the initial, straightforward solution.
    - `Optimal.java` containing the final, efficient interview-ready solution.

---

## ðŸ“‚ DSA Patterns & Problems

This collection is organized by common, high-impact patterns. Mastering these will give you the tools to solve a wide variety of interview questions.

### âœ… Problem Checklist

#### ðŸ”¢ **01. Prefix Sum**
- [ ] LC 303 â€“ Range Sum Query: Immutable
- [ ] LC 525 â€“ Contiguous Array
- [ ] LC 560 â€“ Subarray Sum Equals K

#### ðŸ‘¯â€â™‚ï¸ **02. Two Pointers**
- [ ] LC 167 â€“ Two Sum II
- [ ] LC 15 â€“ 3Sum
- [ ] LC 11 â€“ Container With Most Water

#### ðŸªŸ **03. Sliding Window**
- [ ] LC 643 â€“ Max Average Subarray I
- [ ] LC 3 â€“ Longest Substring Without Repeating Characters
- [ ] LC 76 â€“ Minimum Window Substring

#### ðŸ¢ **04. Fast & Slow Pointers**
- [ ] LC 141 â€“ Linked List Cycle
- [ ] LC 202 â€“ Happy Number
- [ ] LC 287 â€“ Find the Duplicate Number

#### ðŸ” **05. Linked List (In-Place Reversal)**
- [ ] LC 206 â€“ Reverse Linked List
- [ ] LC 92 â€“ Reverse Linked List II
- [ ] LC 24 â€“ Swap Nodes in Pairs

#### ðŸ“‰ **06. Monotonic Stack**
- [ ] LC 496 â€“ Next Greater Element I
- [ ] LC 739 â€“ Daily Temperatures
- [ ] LC 84 â€“ Largest Rectangle in Histogram

#### ðŸ¥‡ **07. Top 'K' Elements (Heaps)**
- [ ] LC 215 â€“ Kth Largest Element in an Array
- [ ] LC 347 â€“ Top K Frequent Elements
- [ ] LC 373 â€“ Find K Pairs with Smallest Sums

#### ðŸ“† **08. Intervals**
- [ ] LC 56 â€“ Merge Intervals
- [ ] LC 57 â€“ Insert Interval
- [ ] LC 435 â€“ Non-overlapping Intervals

#### ðŸ” **09. Modified Binary Search**
- [ ] LC 33 â€“ Search in Rotated Sorted Array
- [ ] LC 153 â€“ Find Minimum in Rotated Sorted Array
- [ ] LC 240 â€“ Search a 2D Matrix II

#### ðŸŒ² **10. Binary Tree Traversal**
- [ ] LC 257 â€“ Binary Tree Paths
- [ ] LC 230 â€“ Kth Smallest Element in a BST
- [ ] LC 124 â€“ Binary Tree Maximum Path Sum
- [ ] LC 107 â€“ Level Order Traversal II

#### ðŸ§  **11. Depth First Search (DFS)**
- [ ] LC 133 â€“ Clone Graph
- [ ] LC 113 â€“ Path Sum II
- [ ] LC 210 â€“ Course Schedule II

#### ðŸŒŠ **12. Breadth First Search (BFS)**
- [ ] LC 102 â€“ Binary Tree Level Order Traversal
- [ ] LC 994 â€“ Rotting Oranges
- [ ] LC 127 â€“ Word Ladder

#### ðŸ§® **13. Matrix Traversal**
- [ ] LC 733 â€“ Flood Fill
- [ ] LC 200 â€“ Number of Islands
- [ ] LC 130 â€“ Surrounded Regions

#### ðŸ§© **14. Backtracking**
- [ ] LC 46 â€“ Permutations
- [ ] LC 78 â€“ Subsets
- [ ] LC 51 â€“ N-Queens

#### ðŸ’¸ **15. Dynamic Programming**
- [ ] LC 70 â€“ Climbing Stairs
- [ ] LC 322 â€“ Coin Change
- [ ] LC 300 â€“ Longest Increasing Subsequence
- [ ] LC 416 â€“ Partition Equal Subset Sum
- [ ] LC 1143 â€“ Longest Common Subsequence
- [ ] LC 312 â€“ Burst Balloons

---

## ðŸŒŸ Bonus Problems

These problems often combine multiple patterns and are great for strengthening your problem-solving toolkit.

- [ ] LC 23 â€“ Merge K Sorted Lists *(Heap + Linked List)*
- [ ] LC 138 â€“ Copy List with Random Pointer *(HashMap + Linked List)*
- [ ] LC 329 â€“ Longest Increasing Path in Matrix *(DFS + Memoization)*
- [ ] LC 212 â€“ Word Search II *(Trie + Backtracking)*

---

## ðŸš€ Beyond Code: Complexity Analysis

Remember, the solution is only half the battle. For every problem, make sure you can confidently state and defend the **Time and Space Complexity** of your approach. The `README.md` for each problem will include a complexity analysis table.

---

## ðŸ™Œ Contribute & Connect

This is a living repository. If you find a bug, have a suggestion, or want to add a new pattern/problem, please **open an issue or submit a pull request**. Let's improve this resource together!

### â­ If You Found This Helpful...

Please give this repo a star! It not only motivates me to keep it updated but also helps other students discover it.

> "Consistency beats cramming. One pattern a day keeps rejection away."
